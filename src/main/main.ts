import "dotenv/config";
import {
    app,
    BrowserWindow,
    ipcMain,
    Menu,
    MenuItemConstructorOptions,
    protocol,
    net,
} from "electron";
import * as path from "path";
import { pathToFileURL } from "url";
import { AppBuilder } from "./AppBuilder";
import { resolveDependencies } from "./dependencies";
import { fileSystemService } from "../@infrastructure/storage/FileSystemService";
import { ComfyAssetGenerationService } from "../@infrastructure/ai/ComfyAssetGenerationService";
import {
    setupService,
    SetupConfig,
} from "../@infrastructure/services/SetupService";
import {
    modelDownloadService,
    DownloadProgress,
} from "../@infrastructure/services/ModelDownloadService";
import { languageToolService } from "../@infrastructure/services/LanguageToolService";
import { SETUP_CHANNELS } from "../@interface-adapters/controllers/setup/setupChannels";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_WEBPACK_ENTRY: string;
declare const LOADING_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETUP_WINDOW_WEBPACK_ENTRY: string;
declare const SETUP_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle Squirrel events for Windows installer (install/uninstall/update)
const handleSquirrelEvent = (): boolean => {
    if (process.platform !== "win32") {
        return false;
    }

    const squirrelCommand = process.argv[1];
    if (!squirrelCommand) {
        return false;
    }

    const { spawn } = require("child_process");
    const fs = require("fs");
    const appFolder = path.resolve(process.execPath, "..");
    const rootFolder = path.resolve(appFolder, "..");
    const updateExe = path.resolve(rootFolder, "Update.exe");
    const exeName = path.basename(process.execPath);

    const spawnUpdate = (args: string[]) => {
        try {
            spawn(updateExe, args, { detached: true });
        } catch {
            // Ignore spawn errors
        }
    };

    // Squirrel passes version as argument: --squirrel-uninstall 1.0.0
    if (
        squirrelCommand === "--squirrel-install" ||
        squirrelCommand === "--squirrel-updated"
    ) {
        // Create shortcuts
        spawnUpdate(["--createShortcut", exeName]);
        setTimeout(() => app.quit(), 1000);
        return true;
    }

    if (squirrelCommand === "--squirrel-uninstall") {
        // Remove shortcuts
        spawnUpdate(["--removeShortcut", exeName]);

        // Clean up downloaded AI files and user data
        try {
            const userDataPath = app.getPath("userData");
            const serverPath = path.join(process.resourcesPath || "", "server");

            // Delete setup config
            const configPath = path.join(userDataPath, "inkline-setup.json");
            if (fs.existsSync(configPath)) {
                fs.unlinkSync(configPath);
                console.log("[Uninstall] Removed setup config");
            }

            // Delete server directory (contains ComfyUI, models, LanguageTool)
            if (fs.existsSync(serverPath)) {
                fs.rmSync(serverPath, { recursive: true, force: true });
                console.log("[Uninstall] Removed server directory");
            }

            // Delete any cached data in userData
            const cachePaths = ["Cache", "GPUCache", "logs"];
            for (const cachePath of cachePaths) {
                const fullPath = path.join(userDataPath, cachePath);
                if (fs.existsSync(fullPath)) {
                    fs.rmSync(fullPath, { recursive: true, force: true });
                }
            }
            console.log("[Uninstall] Cleanup complete");
        } catch (err) {
            console.error("[Uninstall] Cleanup error:", err);
        }

        setTimeout(() => app.quit(), 1000);
        return true;
    }

    if (squirrelCommand === "--squirrel-obsolete") {
        app.quit();
        return true;
    }

    return false;
};

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (handleSquirrelEvent()) {
    // Squirrel event handled, don't continue with normal startup
} else if (require("electron-squirrel-startup")) {
    app.quit();
}

// Register custom protocol scheme for serving local assets securely.
// Must be called before app is ready.
protocol.registerSchemesAsPrivileged([
    {
        scheme: "inkline-asset",
        privileges: {
            secure: true,
            supportFetchAPI: true,
            bypassCSP: true,
            stream: true,
        },
    },
]);

const dependencies = resolveDependencies();
const appBuilder = new AppBuilder(dependencies);

let loadingWindow: BrowserWindow | null = null;
let setupWindow: BrowserWindow | null = null;

const createLoadingWindow = (): void => {
    loadingWindow = new BrowserWindow({
        width: 300,
        height: 200,
        frame: false,
        transparent: false,
        alwaysOnTop: true,
        resizable: false,
        backgroundColor: "#1e1e1e",
        webPreferences: {
            nodeIntegration: false,
            contextIsolation: true,
            preload: LOADING_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    loadingWindow.loadURL(LOADING_WINDOW_WEBPACK_ENTRY);
};

const createSetupWindow = (): Promise<void> => {
    return new Promise((resolve) => {
        setupWindow = new BrowserWindow({
            width: 600,
            height: 700,
            frame: false,
            resizable: false,
            center: true,
            backgroundColor: "#1a1b1e",
            webPreferences: {
                nodeIntegration: false,
                contextIsolation: true,
                preload: SETUP_WINDOW_PRELOAD_WEBPACK_ENTRY,
            },
        });

        setupWindow.loadURL(SETUP_WINDOW_WEBPACK_ENTRY);

        // Setup IPC handlers for this window
        setupSetupIpcHandlers(resolve);

        // Cancel any in-progress AI downloads when window is closing
        // Don't cancel LanguageTool - it downloads in background and should complete
        setupWindow.on("close", () => {
            modelDownloadService.cancelDownload("comfyui");
            modelDownloadService.cancelDownload("image");
            modelDownloadService.cancelDownload("audio");
        });

        setupWindow.on("closed", () => {
            setupWindow = null;
        });
    });
};

const setupSetupIpcHandlers = (onComplete: () => void): void => {
    // Complete setup and launch main app
    ipcMain.handle(
        SETUP_CHANNELS.COMPLETE_SETUP,
        async (
            _event,
            config: {
                features: {
                    aiChat: boolean;
                    imageGeneration: boolean;
                    audioGeneration: boolean;
                };
                theme: { colorScheme: "dark" | "light"; accentColor: string };
            },
        ) => {
            await setupService.saveConfig({
                setupCompleted: true,
                features: config.features,
                theme: config.theme,
            });

            if (setupWindow) {
                setupWindow.close();
                setupWindow = null;
            }

            onComplete();
        },
    );

    // Check platform for Windows-only features
    ipcMain.handle(SETUP_CHANNELS.CHECK_PLATFORM, async () => {
        return {
            platform: process.platform,
            isWindows: process.platform === "win32",
        };
    });

    // Check if ComfyUI is installed
    ipcMain.handle(SETUP_CHANNELS.CHECK_COMFYUI_STATUS, async () => {
        const installed = await modelDownloadService.isComfyUIInstalled();
        return { installed };
    });

    // Check if LanguageTool is installed
    ipcMain.handle(SETUP_CHANNELS.CHECK_LANGUAGETOOL_STATUS, async () => {
        const installed = await modelDownloadService.isLanguageToolInstalled();
        return { installed };
    });

    // Start downloads (ComfyUI + models + LanguageTool)
    ipcMain.handle(
        SETUP_CHANNELS.START_DOWNLOADS,
        async (
            _event,
            request: {
                comfyui: boolean;
                image: boolean;
                audio: boolean;
                languagetool: boolean;
            },
        ) => {
            const sendProgress = (progress: DownloadProgress) => {
                if (setupWindow && !setupWindow.isDestroyed()) {
                    setupWindow.webContents.send(
                        SETUP_CHANNELS.DOWNLOAD_PROGRESS,
                        progress,
                    );
                }
            };

            // Download ComfyUI first if requested
            if (request.comfyui) {
                try {
                    await modelDownloadService.downloadComfyUI(sendProgress);
                    await setupService.markComfyUIInstalled(true);
                } catch (err) {
                    console.error("ComfyUI download failed:", err);
                    // If ComfyUI fails, we can't proceed with model downloads
                    return;
                }
            }

            // Then download models in parallel
            const modelDownloads: Promise<void>[] = [];

            if (request.image) {
                modelDownloads.push(
                    modelDownloadService
                        .downloadModel("image", sendProgress)
                        .then(() =>
                            setupService.markModelDownloaded("image", true),
                        )
                        .catch((err) => {
                            console.error("Image model download failed:", err);
                        }),
                );
            }

            if (request.audio) {
                modelDownloads.push(
                    modelDownloadService
                        .downloadModel("audio", sendProgress)
                        .then(() =>
                            setupService.markModelDownloaded("audio", true),
                        )
                        .catch((err) => {
                            console.error("Audio model download failed:", err);
                        }),
                );
            }

            await Promise.all(modelDownloads);

            // Download LanguageTool (Java JRE + server) if requested
            // This runs after models since it's independent
            if (request.languagetool) {
                try {
                    await modelDownloadService.downloadLanguageTool(
                        sendProgress,
                    );
                    await setupService.markLanguageToolInstalled(true);
                } catch (err) {
                    console.error("LanguageTool download failed:", err);
                    // Non-fatal - app can use public API fallback
                }
            }
        },
    );

    // Cancel downloads
    ipcMain.handle(
        SETUP_CHANNELS.CANCEL_DOWNLOADS,
        async (
            _,
            types?: ("comfyui" | "image" | "audio" | "languagetool")[],
        ) => {
            if (types && types.length > 0) {
                // Cancel only specific download types
                for (const type of types) {
                    modelDownloadService.cancelDownload(type);
                }
            } else {
                // Cancel all if no types specified
                modelDownloadService.cancelAllDownloads();
            }
        },
    );

    // Check model status
    ipcMain.handle(SETUP_CHANNELS.CHECK_MODEL_STATUS, async () => {
        const [imageDownloaded, audioDownloaded] = await Promise.all([
            modelDownloadService.isModelDownloaded("image"),
            modelDownloadService.isModelDownloaded("audio"),
        ]);
        return { image: imageDownloaded, audio: audioDownloaded };
    });
};

const createWindow = (): void => {
    const mainWindow = new BrowserWindow({
        height: 600,
        width: 800,
        minWidth: 1200,
        show: false,
        transparent: false,
        vibrancy: "under-window",
        visualEffectState: "active",
        titleBarStyle: process.platform === "darwin" ? "hiddenInset" : "hidden",
        ...(process.platform !== "darwin"
            ? {
                  titleBarOverlay: {
                      // Keep this aligned with renderer CSS variables defaults.
                      // Renderer reserves 1px for the divider to show under native window controls.
                      height: 35,
                      // Keep this aligned with renderer CSS variables defaults.
                      // Renderer will override dynamically via IPC when the user changes theme.
                      color: "#222324",
                      symbolColor: "#f6f7fb",
                  },
              }
            : {}),
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        },
    });

    if (!app.isPackaged) {
        mainWindow.webContents.openDevTools({ mode: "detach" });
    }

    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
    mainWindow.maximize();
    mainWindow.show();
};

const setupContextMenu = (): void => {
    ipcMain.on("ui:show-context-menu", (event, type, data) => {
        const template: MenuItemConstructorOptions[] = [];

        if (type === "editor") {
            template.push(
                { role: "undo" },
                { role: "redo" },
                { type: "separator" },
                { role: "cut" },
                { role: "copy" },
                { role: "paste" },
                { type: "separator" },
                { role: "selectAll" },
            );
        } else if (type === "binder_chapter") {
            template.push(
                {
                    label: "Rename",
                    click: () => {
                        event.sender.send("context-menu-command", {
                            command: "rename",
                            data,
                        });
                    },
                },
                {
                    label: "Delete",
                    click: () => {
                        event.sender.send("context-menu-command", {
                            command: "delete",
                            data,
                        });
                    },
                },
            );
        } else if (type === "binder_project") {
            template.push({
                label: "Close Project",
                click: () => {
                    event.sender.send("context-menu-command", {
                        command: "close-project",
                        data,
                    });
                },
            });
        }

        if (template.length > 0) {
            const menu = Menu.buildFromTemplate(template);
            menu.popup({
                window:
                    BrowserWindow.fromWebContents(event.sender) || undefined,
            });
        }
    });
};

const bootstrap = async (): Promise<void> => {
    // Register the custom protocol handler first.
    // This handles inkline-asset://local/assets/project/xxx/image.jpg URLs
    protocol.handle("inkline-asset", (request) => {
        // URL format: inkline-asset://local/assets/project/xxx/image.jpg
        // host = "local", pathname = "/assets/project/xxx/image.jpg"
        const url = new URL(request.url);
        const relativePath = decodeURIComponent(url.pathname).replace(
            /^\//,
            "",
        );
        const basePath = fileSystemService.getBasePath();
        const filePath = path.join(basePath, relativePath);

        // Security check: Ensure the resolved path is still within the base path
        if (!filePath.startsWith(basePath)) {
            console.error(
                `[Security] Blocked path traversal attempt: ${relativePath}`,
            );
            return new Response("Access Denied", { status: 403 });
        }

        // Use pathToFileURL for proper cross-platform file URL conversion
        return net.fetch(pathToFileURL(filePath).toString());
    });

    // Check if this is a first-time run
    // Use --force-setup flag to force the setup wizard (for testing)
    const forceSetup = app.commandLine.hasSwitch("force-setup");
    const isFirstRun = forceSetup || (await setupService.isFirstRun());

    if (forceSetup) {
        console.log("[Main] Force setup flag detected - showing setup wizard");
    }

    if (isFirstRun) {
        // Show setup wizard and wait for completion
        await createSetupWindow();
    }

    createLoadingWindow();

    setupContextMenu();

    await appBuilder.build();

    const comfyService = dependencies.services.audioGeneration;
    if (comfyService && typeof comfyService.waitForReady === "function") {
        try {
            await comfyService.waitForReady();
        } catch (error) {
            console.error("Failed to start ComfyUI service:", error);
        }
    }

    // Initialize LanguageTool server (will use public API fallback if not installed)
    try {
        await languageToolService.waitForReady();
        console.log(
            `[Main] LanguageTool ready - using ${languageToolService.isUsingLocalServer() ? "local server" : "public API"}`,
        );
    } catch (error) {
        console.error("Failed to initialize LanguageTool service:", error);
    }

    if (loadingWindow) {
        loadingWindow.close();
        loadingWindow = null;
    }

    createWindow();
};

app.whenReady()
    .then(() => bootstrap())
    .catch((error) => {
        console.error("Failed to bootstrap application", error);
        app.quit();
    });

ipcMain.handle(
    "window:setTitleBarOverlay",
    (
        event,
        overlay: {
            color: string;
            symbolColor?: string;
            height?: number;
        },
    ) => {
        if (process.platform === "darwin") {
            return;
        }

        const win = BrowserWindow.fromWebContents(event.sender);
        if (!win) {
            return;
        }

        const setOverlay = (
            win as unknown as { setTitleBarOverlay?: (o: unknown) => void }
        ).setTitleBarOverlay;
        if (typeof setOverlay !== "function") {
            return;
        }

        setOverlay(overlay);
    },
);

// LanguageTool IPC handlers - all HTTP calls are made from main process to avoid CORS
ipcMain.handle(
    "languageTool:checkGrammar",
    async (_event, request: { text: string; language: string }) => {
        return languageToolService.checkGrammar(request);
    },
);

ipcMain.handle("languageTool:isUsingLocalServer", async () => {
    return languageToolService.isUsingLocalServer();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
    if (process.platform !== "darwin") {
        app.quit();
    }
});

app.on("activate", () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});
